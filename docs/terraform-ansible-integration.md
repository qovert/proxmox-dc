# Terraform + Ansible Integration for Windows AD

This document explains how to use Ansible for configuration management instead of inline PowerShell scripts.

## Why Ansible for Windows Configuration?

### Advantages
- **Idempotent**: Re-run safely without side effects
- **Declarative**: Define desired state, not steps
- **Modular**: Reusable roles and playbooks
- **Error Handling**: Better error recovery and rollback
- **Testing**: Built-in testing and validation
- **Version Control**: Configuration as code with Git

### Modern Windows Ansible Support
- **WinRM/SSH connectivity**: Both protocols supported
- **PowerShell modules**: Native PowerShell DSC integration  
- **Windows modules**: Comprehensive Windows-specific modules
- **Active Directory**: Dedicated AD management modules

## Architecture

```
Terraform (Infrastructure) → Ansible (Configuration)
     ↓                            ↓
Infrastructure Layer         Configuration Layer
- VM Creation               - AD Installation
- Network Setup            - DNS Configuration  
- Storage Allocation       - Security Policies
- Basic OS Config          - Service Management
```

## Setup Instructions

### 1. Install Ansible with Windows Support

```bash
# Install Ansible with Windows collections
pip install ansible pywinrm requests-kerberos

# Install Windows collections
ansible-galaxy collection install ansible.windows
ansible-galaxy collection install community.windows
ansible-galaxy collection install microsoft.ad
```

### 2. Terraform Configuration Changes

The Terraform configuration is simplified to focus only on infrastructure:

```hcl
# Generate Ansible inventory from Terraform outputs
resource "local_file" "ansible_inventory" {
  content = templatefile("${path.module}/templates/inventory.yml.tpl", {
    domain_controllers = [
      for i, dc in proxmox_virtual_environment_vm.windows_dc : {
        name       = dc.name
        ip_address = local.dc_ips[i]
        vm_id      = dc.vm_id
        is_primary = i == 0
      }
    ]
    domain_name = var.domain_name
    admin_user  = var.admin_username
  })
  filename = "${path.module}/ansible/inventory.yml"
}

# Generate Ansible variables
resource "local_file" "ansible_vars" {
  content = templatefile("${path.module}/templates/group_vars.yml.tpl", {
    domain_name              = var.domain_name
    netbios_name            = var.netbios_name
    admin_password          = var.admin_password
    dsrm_password           = var.dsrm_password
    domain_functional_level = var.domain_functional_level
    forest_functional_level = var.forest_functional_level
    dns_forwarders          = var.dns_forwarders
    organizational_units    = var.organizational_units
    password_policy         = var.password_policy
  })
  filename = "${path.module}/ansible/group_vars/domain_controllers.yml"
}

# Run Ansible after infrastructure is ready
resource "null_resource" "run_ansible" {
  depends_on = [
    proxmox_virtual_environment_vm.windows_dc,
    local_file.ansible_inventory,
    local_file.ansible_vars
  ]

  triggers = {
    inventory_hash = local_file.ansible_inventory.content_md5
    vars_hash     = local_file.ansible_vars.content_md5
  }

  provisioner "local-exec" {
    command = <<-EOT
      cd ansible
      ansible-playbook -i inventory.yml site.yml --vault-password-file vault_pass
    EOT
  }
}
```

### 3. Ansible Directory Structure

```
ansible/
├── ansible.cfg
├── inventory.yml (generated by Terraform)
├── group_vars/
│   └── domain_controllers.yml (generated by Terraform)
├── site.yml
├── roles/
│   ├── windows_base/
│   ├── active_directory/
│   ├── dns_server/
│   └── monitoring/
└── vault_pass
```

## Implementation

Let me create the Ansible setup:
